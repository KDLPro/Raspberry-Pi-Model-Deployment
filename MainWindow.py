# Form implementation generated from reading ui file 'FiberWatch_App.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.

import os, traceback, sys, shutil

from Dialog import Ui_Dialog

from PyQt6 import QtCore, QtGui, QtWidgets
from PyQt6.QtWidgets import QFileDialog, QGraphicsScene, QDialog, QGraphicsPixmapItem
from PyQt6.QtGui import QPixmap, QImage
from PyQt6.QtCore import Qt, QRunnable, QThreadPool, pyqtSignal, QObject, pyqtSlot

import cv2

from ultralytics import YOLO

from supabase import create_client

import matplotlib.pyplot as plt
from matplotlib.backends.backend_agg import FigureCanvasAgg
import numpy as np

import Keys

class WorkerSignals(QObject):
    '''
    Defines the signals available from a running worker thread.

    Supported signals are:

    finished
        No data

    error
        tuple (exctype, value, traceback.format_exc() )

    result
        object data returned from processing, anything

    '''
    finished = pyqtSignal()
    error = pyqtSignal(tuple)
    result = pyqtSignal(object)

class Worker(QRunnable):
    '''
    Worker thread

    Inherits from QRunnable to handler worker thread setup, signals and wrap-up.

    :param callback: The function callback to run on this worker thread. Supplied args and
                     kwargs will be passed through to the runner.
    :type callback: function
    :param args: Arguments to pass to the callback function
    :param kwargs: Keywords to pass to the callback function

    '''

    def __init__(self, function, *args, **kwargs):
        super().__init__()

        # Constructor arguments
        self.function = function
        self.args = args
        self.kwargs = kwargs
        self.signals = WorkerSignals()

    @pyqtSlot()
    def run(self):
        '''
        Initialise the runner function with passed args, kwargs.
        '''

        try:
            result = self.function(
                *self.args, **self.kwargs
            )
        except:
            traceback.print_exc()
            exctype, value = sys.exc_info()[:2]
            self.signals.error.emit((exctype, value, traceback.format_exc()))
        else:
            self.signals.result.emit(result)  # Return the result of the processing
        finally:
            self.signals.finished.emit()  # Done

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1024, 550)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMinimumSize(QtCore.QSize(1024, 550))
        MainWindow.setMaximumSize(QtCore.QSize(1024, 550))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(0, 170, 69))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Button, brush)
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Window, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Button, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Window, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Base, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Window, brush)
        brush = QtGui.QBrush(QtGui.QColor(184, 200, 188))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Button, brush)
        MainWindow.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Satoshi")
        font.setPointSize(12)
        font.setBold(False)
        MainWindow.setFont(font)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("icons/logo.png"), QtGui.QIcon.Mode.Normal, QtGui.QIcon.State.Off)
        MainWindow.setWindowIcon(icon)
        MainWindow.setStyleSheet("")
        MainWindow.setIconSize(QtCore.QSize(48, 48))
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setStyleSheet("border-bottom: 1px solid rgb(0, 170, 69);")
        self.centralwidget.setObjectName("centralwidget")
        self.title_label = QtWidgets.QLabel(parent=self.centralwidget)
        self.title_label.setGeometry(QtCore.QRect(412, 10, 200, 31))
        font = QtGui.QFont()
        font.setFamily("Satoshi Medium")
        font.setPointSize(24)
        font.setBold(True)
        self.title_label.setFont(font)
        self.title_label.setStyleSheet("color: rgb(0, 85, 0)")
        self.title_label.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.title_label.setObjectName("title_label")
        self.image = QtWidgets.QGraphicsView(parent=self.centralwidget)
        self.image.setGeometry(QtCore.QRect(50, 120, 410, 350))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.image.sizePolicy().hasHeightForWidth())
        self.image.setSizePolicy(sizePolicy)
        self.image.setMaximumSize(QtCore.QSize(410, 350))
        self.image.setStyleSheet("background-color: #AFBE87")
        self.image.setFrameShape(QtWidgets.QFrame.Shape.Box)
        self.image.setFrameShadow(QtWidgets.QFrame.Shadow.Plain)
        self.image.setLineWidth(1)
        self.image.setObjectName("image")
        self.graph = QtWidgets.QGraphicsView(parent=self.centralwidget)
        self.graph.setGeometry(QtCore.QRect(564, 120, 410, 350))
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Policy.Fixed, QtWidgets.QSizePolicy.Policy.Fixed)
        self.graph.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.graph.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.graph.sizePolicy().hasHeightForWidth())
        self.graph.setSizePolicy(sizePolicy)
        self.graph.setMaximumSize(QtCore.QSize(410, 350))
        self.graph.setStyleSheet("background-color: #AFBE87")
        self.graph.setFrameShape(QtWidgets.QFrame.Shape.Box)
        self.graph.setFrameShadow(QtWidgets.QFrame.Shadow.Plain)
        self.graph.setLineWidth(1)
        self.graph.setObjectName("graph")
        self.label_2 = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_2.setGeometry(QtCore.QRect(205, 80, 100, 30))
        font = QtGui.QFont()
        font.setFamily("Satoshi Medium")
        font.setPointSize(18)
        font.setBold(True)
        self.label_2.setFont(font)
        self.label_2.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.label_3 = QtWidgets.QLabel(parent=self.centralwidget)
        self.label_3.setGeometry(QtCore.QRect(704, 80, 130, 30))
        font = QtGui.QFont()
        font.setFamily("Satoshi Medium")
        font.setPointSize(18)
        font.setBold(True)
        self.label_3.setFont(font)
        self.label_3.setAlignment(QtCore.Qt.AlignmentFlag.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.loadImage = QtWidgets.QPushButton(parent=self.centralwidget)
        self.loadImage.setGeometry(QtCore.QRect(350, 80, 110, 30))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Light, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.ButtonText, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Light, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.ButtonText, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Light, brush)
        self.loadImage.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Satoshi Medium")
        font.setPointSize(12)
        font.setBold(True)
        self.loadImage.setFont(font)
        self.loadImage.setStyleSheet("background-color: rgb(0, 170, 69);")
        self.loadImage.setObjectName("loadImage")
        self.predict = QtWidgets.QPushButton(parent=self.centralwidget)
        self.predict.setGeometry(QtCore.QRect(350, 480, 110, 30))
        palette = QtGui.QPalette()
        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))
        brush.setStyle(QtCore.Qt.BrushStyle.SolidPattern)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.Light, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Active, QtGui.QPalette.ColorRole.ButtonText, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.Light, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Inactive, QtGui.QPalette.ColorRole.ButtonText, brush)
        palette.setBrush(QtGui.QPalette.ColorGroup.Disabled, QtGui.QPalette.ColorRole.Light, brush)
        self.predict.setPalette(palette)
        font = QtGui.QFont()
        font.setFamily("Satoshi Medium")
        font.setPointSize(12)
        font.setBold(True)
        self.predict.setFont(font)
        self.predict.setStyleSheet("background-color: rgb(0, 170, 69);")
        self.predict.setObjectName("predict")
        MainWindow.setCentralWidget(self.centralwidget)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        font.setFamily("Satoshi")
        font.setPointSize(11)
        font.setBold(True)
        self.statusbar.setFont(font)
        MainWindow.setStatusBar(self.statusbar)
        self.img_scene = QGraphicsScene()

        # Buttons to functions
        self.loadImage.clicked.connect(self.openImage)
        self.predict.clicked.connect(self.generatePreds)

        # Threads
        self.thread_manager = QThreadPool()

        # Variables
        self.imgPath = ""
        self.grade_s2 = [0]
        self.grade_s3 = [0]
        self.length_grades = [0]

        # Call supabase client
        self.initSupabaseClient()

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def initSupabaseClient(self):
        self.supabase = create_client(Keys.url, Keys.key)

    def openImage(self):
        self.update_status("Loading image...")
        self.loadImage.setDisabled(True)
        self.loadImage.setStyleSheet("background-color: rgb(0, 236, 96);")

        # Load image
        self.imgPath, _ = QFileDialog.getOpenFileName(self, caption="Open Image", filter="Image Files (*.png *.jpg *.bmp)")

        if (self.imgPath == ""):
            self.loadImageFail()
            return

        # Create a worker to handle predictions
        worker = Worker(self.processImage)

        worker.signals.result.connect(self.displayImage)
        worker.signals.error.connect(self.loadImageFail)
        worker.signals.finished.connect(self.img_load_done)

        # Start the worker
        self.thread_manager.start(worker)

    def processImage(self):
        try: 
            self.update_status("Processing image...")

            cv_image = cv2.imread(self.imgPath, cv2.IMREAD_UNCHANGED)

            # Clear scene
            self.img_scene.clear()
            self.image.resetTransform()

            # Resize image using OpenCV
            view_width = self.image.width() - 2
            view_height = self.image.height() - 2
            
            original_width = cv_image.shape[1]
            original_height = cv_image.shape[0]

            width_scale = view_width / original_width
            height_scale = view_height / original_height

            scale_factor = min(width_scale, height_scale)

            new_width = int(original_width * scale_factor)
            new_height = int(original_height * scale_factor)

            # Resize the image with OpenCV while maintaining the aspect ratio
            resized_cv_image = cv2.resize(cv_image, (new_width, new_height))

            # Check if the image has 4 channels (RGBA) or 3 channels (RGB)
            if resized_cv_image.shape[2] == 4: 
                resized_cv_image_rgb = cv2.cvtColor(resized_cv_image, cv2.COLOR_BGRA2RGBA)
            else:  
                resized_cv_image_rgb = cv2.cvtColor(resized_cv_image, cv2.COLOR_BGR2RGB)

            return resized_cv_image_rgb  # Pass processed image back to main thread

        except Exception as e:
            raise e  # Worker will emit error signal

    def displayImage(self, resized_cv_image_rgb):
        try:
            # Convert the OpenCV image to QImage
            height, width, channel = resized_cv_image_rgb.shape
            bytes_per_line = 3 * width if channel == 3 else 4 * width  # 3 for RGB, 4 for RGBA
            qimage = QImage(resized_cv_image_rgb.data, width, height, bytes_per_line, QImage.Format.Format_RGB888 if channel == 3 else QImage.Format.Format_RGBA8888)
            scaledPixmap = QPixmap.fromImage(qimage)
            
            # Display image in the graphics window
            pixmap_item = QGraphicsPixmapItem(scaledPixmap)
            self.image.setStyleSheet("background-color: #FFFFFF")

            self.img_scene.addItem(pixmap_item)
            self.image.fitInView(self.img_scene.sceneRect(), Qt.AspectRatioMode.KeepAspectRatio)
            self.image.centerOn(255, 295)
            self.image.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.image.setScene(self.img_scene)

            self.statusbar.clearMessage()

        except Exception as e:
            print("Loading image failed.")

    def loadImageFail(self):
        # Clears the graphics view when image loading has failed, and resets variables
        AlertImage()
        self.img_scene.clear()
        self.image.setStyleSheet("background-color: #AFBE87")
        self.imgPath = ""
        
        self.loadImage.setDisabled(False)
        self.loadImage.setStyleSheet("background-color: rgb(0, 170, 69);")

    def generatePreds(self):
        self.update_status("Processing image...")
        self.predict.setDisabled(True)
        self.predict.setStyleSheet("background-color: rgb(0, 236, 96);")

        # Create a worker to handle predictions
        worker = Worker(self.loadModelAndPredict)

        worker.signals.result.connect(self.handlePredResult)
        worker.signals.error.connect(self.predictionFail)
        worker.signals.finished.connect(self.prediction_done)

        # Start the worker
        self.thread_manager.start(worker)
        
    def loadModelAndPredict(self):
        curr_dir = os.getcwd()
        custom_save_dir = os.path.join(curr_dir, "results")
        custom_save_dir = os.path.normpath(custom_save_dir)
        
        # Remove the custom save directory if it exists, then remake it
        try:
            shutil.rmtree(custom_save_dir)
            print(f"Folder '{custom_save_dir}' and all its contents have been deleted.")
        except OSError as e:
            print(f"Error: {e.strerror}.")

        os.makedirs(custom_save_dir, exist_ok=True)
        print(custom_save_dir)

        # Load a YOLO11n PyTorch model and export to NCNN format
        
        if (os.path.exists("models/November-23_ncnn_model") == False):
            model = YOLO("models/November-23.pt")
            model.export(format="ncnn") 

        ncnn_model = YOLO("models/November-23_ncnn_model", task="detect")
        results = ncnn_model.predict(self.imgPath, project=custom_save_dir, save=True, exist_ok=True, save_txt=True, iou=0.2, agnostic_nms=True)

        # Get image location
        base_img = os.path.basename(self.imgPath)
        final_img = os.path.join(custom_save_dir, "predict", base_img)
        final_img = os.path.normpath(final_img) 

        # Get labels location
        img_without_ext = os.path.splitext(base_img)[0]
        labels_dir = os.path.join(custom_save_dir, "predict", "labels")
        labels_dir = os.path.normpath(labels_dir)
        txt_file = os.path.join(labels_dir, f"{img_without_ext}.txt")
        txt_file = os.path.normpath(txt_file)

        return [final_img, txt_file]

    def handlePredResult(self, result_arr):
        try: 
            # Process image first
            cv_image = cv2.imread(result_arr[0], cv2.IMREAD_UNCHANGED)

            # Resize image using OpenCV
            view_width = self.image.width() - 2
            view_height = self.image.height() - 2
            
            original_width = cv_image.shape[1]
            original_height = cv_image.shape[0]

            width_scale = view_width / original_width
            height_scale = view_height / original_height

            scale_factor = min(width_scale, height_scale)

            new_width = int(original_width * scale_factor)
            new_height = int(original_height * scale_factor)

            # Resize the image with OpenCV while maintaining the aspect ratio
            resized_cv_image = cv2.resize(cv_image, (new_width, new_height))

            # Check if the image has 4 channels (RGBA) or 3 channels (RGB)
            if resized_cv_image.shape[2] == 4: 
                resized_cv_image_rgb = cv2.cvtColor(resized_cv_image, cv2.COLOR_BGRA2RGBA)
            else:  
                resized_cv_image_rgb = cv2.cvtColor(resized_cv_image, cv2.COLOR_BGR2RGB)

            # Convert the OpenCV image to QImage
            height, width, channel = resized_cv_image_rgb.shape
            bytes_per_line = 3 * width if channel == 3 else 4 * width  # 3 for RGB, 4 for RGBA
            qimage = QImage(resized_cv_image_rgb.data, width, height, bytes_per_line, QImage.Format.Format_RGB888 if channel == 3 else QImage.Format.Format_RGBA8888)
            scaledPixmap = QPixmap.fromImage(qimage)
            
            # Display image in the graphics window
            pixmap_item = QGraphicsPixmapItem(scaledPixmap)
            self.image.setStyleSheet("background-color: #FFFFFF")

            self.img_scene.addItem(pixmap_item)
            self.image.fitInView(self.img_scene.sceneRect(), Qt.AspectRatioMode.KeepAspectRatio)
            self.image.centerOn(255, 295)
            self.image.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.image.setScene(self.img_scene)

            # Get data about the classification results
            grade_indices = []
            with open(result_arr[1], "r") as file:
                for line in file:
                    tokens = line.split()
                    if tokens and tokens[0].isdigit():
                        grade_indices.append(int(tokens[0]))
                    elif tokens:  # Try converting non-integer numbers (e.g., float)
                        try:
                            grade_indices.append(float(tokens[0]))
                        except ValueError:
                            pass

            grades = [0, 0]
            for i in grade_indices:
                if i == 0:          # Grade S2
                    grades[0] += 1
                elif i == 1:        # Grade S3
                    grades[1] += 1

            # Uploading results to Supabase
            self.update_status("Uploading results to Supabase database...")
            for i in range(2):
                if i == 0:
                    self.grade_s2.append(grades[0])
                else:
                    self.grade_s3.append(grades[1])
                if grades[i] == 0:
                    continue
                grade_code = "S2" if (i == 1) else "S3"
                response = (
                    self.supabase.table("fiber_scanning_logs")
                    .insert({"fiber_grade": grade_code, "number_of_fibers": grades[i]})
                    .execute()
                )

            self.length_grades.append(len(self.length_grades))
    def predictionFail(self):
        AlertPrediction()
        
        self.predict.setDisabled(False)
        self.predict.setStyleSheet("background-color: rgb(0, 170, 69);")

    def img_load_done(self):
        self.update_status("Image loaded successfully!", timeout = 2000)
        self.loadImage.setDisabled(False)
        self.loadImage.setStyleSheet("background-color: rgb(0, 170, 69);")

    def prediction_done(self):
        self.update_status("Prediction done!", timeout = 2000)
        self.predict.setDisabled(False)
        self.predict.setStyleSheet("background-color: rgb(0, 170, 69);")

    def update_status(self, message, timeout = 0):
        """
        Update the status bar with a message.
        """
        _translate = QtCore.QCoreApplication.translate
        self.statusbar.showMessage(_translate("MainWindow", message), timeout)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "FiberWatch"))
        self.title_label.setText(_translate("MainWindow", "FiberWatch"))
        self.label_2.setText(_translate("MainWindow", "Image"))
        self.label_3.setText(_translate("MainWindow", "Detections"))
        self.loadImage.setToolTip(_translate("MainWindow", "Loads an image for processing by the abaca fiber classification model."))
        self.loadImage.setText(_translate("MainWindow", "Load Image"))
        self.predict.setToolTip(_translate("MainWindow", "Generates predictions based on the loaded image."))
        self.predict.setText(_translate("MainWindow", "Predict!"))

def AlertImage():
    # Alert user via dialog that an image needs to be loaded
    dialog = QDialog()
    ui = Ui_Dialog()
    ui.setupUi(dialog)
    ui.setDialogDetails(dialog, title="Image loading failed!", text="Image must be loaded first!", textColor="#B41C2B")
    dialog.exec()

def AlertPrediction():
    # Alert user via dialog that generating predictions has failed
    dialog = QDialog()
    ui = Ui_Dialog()
    ui.setupUi(dialog)
    ui.setDialogDetails(dialog, 
                        title="Generating predictions failed!", 
                        text="Generating predictions failed. \nPlease check your Internet connection \nand try again", 
                        textColor="#B41C2B")
    dialog.exec()

class Dialog(QtWidgets.QDialog, Ui_Dialog):
    def __init__(self, *args, obj=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.setupUi(self)

        
